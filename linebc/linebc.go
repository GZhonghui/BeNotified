// Generated by AI.

// package linebc provides a minimal LINE broadcast wrapper with explicit Init.
//
// Required credentials:
//   - Channel Secret (LINE_CHANNEL_SECRET)
//   - Channel Access Token (LINE_CHANNEL_ACCESS_TOKEN)
//
// You can either call Init(secret, token) or InitFromEnv().
//
// Usage example:
//
//	err := linebc.InitFromEnv()
//	if err != nil { log.Fatal(err) }
//	if err := linebc.BroadcastText("Hello!"); err != nil { log.Fatal(err) }
package linebc

import (
	"errors"
	"fmt"
	"os"
	"sync"
	"time"

	"github.com/line/line-bot-sdk-go/v7/linebot"
)

var (
	bot             *linebot.Client
	once            sync.Once
	initErr         error
	lastBroadcastMu sync.Mutex
	lastBroadcastTS time.Time
)

// Init initializes the global LINE client exactly once.
// Subsequent calls return the same error/value from the first attempt.
func Init(channelSecret, channelAccessToken string) error {
	once.Do(func() {
		if channelSecret == "" || channelAccessToken == "" {
			initErr = errors.New("linebc: channel secret or access token is empty")
			return
		}
		var err error
		bot, err = linebot.New(channelSecret, channelAccessToken)
		if err != nil {
			initErr = fmt.Errorf("linebc: failed to create LINE client: %w", err)
			return
		}
	})
	return initErr
}

// InitFromEnv loads credentials from environment variables and calls Init.
//   - LINE_CHANNEL_SECRET
//   - LINE_CHANNEL_ACCESS_TOKEN
func InitFromEnv() error {
	secret := os.Getenv("LINE_CHANNEL_SECRET")
	accessToken := os.Getenv("LINE_CHANNEL_ACCESS_TOKEN")
	return Init(secret, accessToken)
}

// IsInitialized reports whether Init succeeded.
func IsInitialized() bool {
	return bot != nil && initErr == nil
}

// BroadcastText sends a single text message to all followers using Broadcast API.
// This function is rate-limited to once per hour to prevent spam.
func BroadcastText(text string) error {
	if bot == nil {
		return errors.New("linebc: client not initialized; call Init or InitFromEnv first")
	}
	if text == "" {
		return errors.New("linebc: text cannot be empty")
	}

	// Check rate limit: only allow once per hour
	lastBroadcastMu.Lock()
	now := time.Now()
	timeSinceLastBroadcast := now.Sub(lastBroadcastTS)
	if timeSinceLastBroadcast < time.Hour && !lastBroadcastTS.IsZero() {
		lastBroadcastMu.Unlock()
		remainingTime := time.Hour - timeSinceLastBroadcast
		return fmt.Errorf("linebc: rate limit exceeded, please wait %v before next broadcast", remainingTime.Round(time.Second))
	}
	lastBroadcastTS = now
	lastBroadcastMu.Unlock()

	_, err := bot.BroadcastMessage(linebot.NewTextMessage(text)).Do()
	return err
}

// BroadcastMessages sends 1â€“5 messages (text, image, flex, template, etc.).
func BroadcastMessages(msgs ...linebot.SendingMessage) error {
	if bot == nil {
		return errors.New("linebc: client not initialized; call Init or InitFromEnv first")
	}
	if n := len(msgs); n == 0 || n > 5 {
		return fmt.Errorf("linebc: message count must be 1-5, got %d", n)
	}
	_, err := bot.BroadcastMessage(msgs...).Do()
	return err
}
